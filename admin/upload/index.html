<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Admin Upload — Jacob Shields</title>
  <link rel="stylesheet" href="/assets/styles.css" />
</head>
<body>
  <main>
    <p class="nav"><a href="/">← Back to home</a><span class="dot">•</span><a href="/admin">Admin</a></p>
    <h1>Admin Upload</h1>
    <p class="small-note">This route is protected by Cloudflare Access. Pick a destination, select files, and upload.</p>

    <div class="upload-meta">
      <label>Destination
        <select id="collection">
          <option value="spincline_design_build">Spincline: Design &amp; Build</option>
          <option value="spincline_finished_products">Spincline: Finished Products</option>
          <option value="spincline_in_action">Spincline: In Action (Video)</option>
          <option value="photography">Photography</option>
        </select>
      </label>
      <input id="files" type="file" multiple accept="image/*,video/*" />
      <button id="upload-all" type="button">Upload all files</button>
    </div>
    <div class="small-note" id="batch-status">No files selected yet.</div>

    <div class="admin-grid" id="queue"></div>
  </main>

  <script>
    const queue = document.getElementById('queue');
    const filesInput = document.getElementById('files');
    const collectionInput = document.getElementById('collection');
    const batchStatus = document.getElementById('batch-status');
    const uploadAllBtn = document.getElementById('upload-all');

    const PUBLIC_LINKS = {
      spincline_design_build: '/spincline#design-build',
      spincline_finished_products: '/spincline#finished-products',
      spincline_in_action: '/spincline#in-action',
      photography: '/photography',
    };

    function api(path, opts = {}) {
      return fetch(path, { ...opts, credentials: 'same-origin' });
    }

    function isPhotographyCollection() {
      return collectionInput.value === 'photography';
    }

    function syncMetadataFields() {
      const photographyMode = isPhotographyCollection();
      queue.querySelectorAll('.upload-file').forEach((card) => {
        const descWrap = card.querySelector('.description-wrap');
        const locationWrap = card.querySelector('.location-wrap');
        if (descWrap) descWrap.hidden = photographyMode;
        if (locationWrap) locationWrap.hidden = !photographyMode;
      });
    }

    function friendlySize(bytes) {
      if (bytes < 1024 * 1024) return `${Math.max(1, Math.round(bytes / 1024))} KB`;
      if (bytes < 1024 * 1024 * 1024) return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
      return `${(bytes / (1024 * 1024 * 1024)).toFixed(2)} GB`;
    }

    function clearPreviewUrls() {
      queue.querySelectorAll('.upload-file').forEach((card) => {
        if (card.dataset.objectUrl) URL.revokeObjectURL(card.dataset.objectUrl);
      });
    }

    const queueItems = [];

    function isHeicFile(file) {
      const name = (file?.name || '').toLowerCase();
      const type = (file?.type || '').toLowerCase();
      return type === 'image/heic' || type === 'image/heif' || name.endsWith('.heic') || name.endsWith('.heif');
    }

    let heicConverterPromise = null;
    async function loadHeicConverter() {
      if (!heicConverterPromise) {
        heicConverterPromise = import('https://cdn.jsdelivr.net/npm/heic2any@0.0.4/+esm').then((mod) => mod.default || mod);
      }
      return heicConverterPromise;
    }

    function toJpegName(fileName = 'upload.heic') {
      return fileName.replace(/\.(heic|heif)$/i, '.jpg');
    }

    async function convertHeicToJpeg(file) {
      const heic2any = await loadHeicConverter();
      const converted = await heic2any({ blob: file, toType: 'image/jpeg', quality: 0.9 });
      const jpegBlob = Array.isArray(converted) ? converted[0] : converted;
      if (!(jpegBlob instanceof Blob)) throw new Error('HEIC conversion returned an invalid file blob.');
      return new File([jpegBlob], toJpegName(file.name), { type: 'image/jpeg', lastModified: Date.now() });
    }

    async function imageDimensions(file) {
      return new Promise((resolve) => {
        if (!file.type.startsWith('image/')) return resolve({});
        const img = new Image();
        const objectUrl = URL.createObjectURL(file);
        img.onload = () => {
          URL.revokeObjectURL(objectUrl);
          resolve({ width: img.naturalWidth, height: img.naturalHeight, aspect_ratio: img.naturalWidth / img.naturalHeight });
        };
        img.onerror = () => {
          URL.revokeObjectURL(objectUrl);
          resolve({});
        };
        img.src = objectUrl;
      });
    }

    function parseError(err, context = {}) {
      const payload = {
        step: context.step || 'unknown',
        url: context.url || '',
        host: '',
        status: context.status || null,
        message: err?.message || String(err || 'Unknown error'),
      };
      if (payload.url) {
        try { payload.host = new URL(payload.url, location.origin).host; } catch {}
      }
      const isFailedFetch = payload.message.toLowerCase().includes('failed to fetch') || err?.name === 'TypeError';
      const isR2Put = payload.step.includes('put') || payload.host.includes('cloudflarestorage.com');
      payload.likelyCause = '';
      if (isFailedFetch && isR2Put && !payload.status) {
        payload.likelyCause = 'Likely R2 CORS misconfiguration. See docs snippet below.';
      } else if (payload.status === 401 || payload.status === 403) {
        payload.likelyCause = 'Likely auth/presign issue (expired URL or Cloudflare Access).';
      } else if (payload.status >= 500) {
        payload.likelyCause = 'Server/network issue. Retry and check function logs.';
      }
      console.error('[upload-error]', payload, err);
      return payload;
    }

    function errorText(parsed) {
      return `Upload failed at ${parsed.step}. host=${parsed.host || '(unknown)'} status=${parsed.status || 'n/a'} error=${parsed.message}${parsed.likelyCause ? ` — ${parsed.likelyCause}` : ''}`;
    }

    function corsHelpPanel() {
      return `<details class="small-note" style="margin-top:8px;"><summary>Fix CORS (Cloudflare R2)</summary><pre style="white-space:pre-wrap;">[
  {
    "AllowedOrigins": ["https://jacobconlanshields.com"],
    "AllowedMethods": ["GET", "HEAD", "PUT", "POST", "DELETE"],
    "AllowedHeaders": ["*"],
    "ExposeHeaders": ["ETag"],
    "MaxAgeSeconds": 3600
  }
]</pre></details>`;
    }

    function fileCard(item) {
      const file = item.originalFile;
      const wrap = document.createElement('section');
      wrap.className = 'upload-file';
      wrap.innerHTML = `
        <h3>${file.name}</h3>
        <div class="small-note">${file.type || 'unknown type'} · ${friendlySize(file.size)}</div>
        <div class="small-note conversion-note"></div>
        <div class="preview-wrap"></div>
        <div class="upload-meta">
          <label>Title <input type="text" class="title" placeholder="Optional"></label>
          <label class="description-wrap">Description <textarea class="description" rows="3" placeholder="Optional"></textarea></label>
          <label class="location-wrap" hidden>Location <input type="text" class="location" placeholder="Optional"></label>
          ${file.type.startsWith('video/') ? '<label>Poster image (optional)<input type="file" class="poster" accept="image/*"></label>' : ''}
          <progress max="100" value="0"></progress>
          <div class="small-note status">Ready.</div>
          <div class="small-note result"></div>
          <button type="button" class="start">Upload</button>
        </div>`;
      wrap.querySelector('.start').addEventListener('click', () => uploadFile(item, wrap));
      return wrap;
    }

    function setPreview(card, file) {
      const previewWrap = card.querySelector('.preview-wrap');
      previewWrap.innerHTML = '';
      if (!file.type.startsWith('image/')) return;
      if (card.dataset.objectUrl) URL.revokeObjectURL(card.dataset.objectUrl);
      const objectUrl = URL.createObjectURL(file);
      card.dataset.objectUrl = objectUrl;
      previewWrap.innerHTML = `<img class="upload-preview" src="${objectUrl}" alt="Preview of ${file.name}" style="max-width:220px; max-height:220px; object-fit:cover; border-radius:8px; margin-top:8px;" />`;
    }

    async function prepareFileForUpload(item, card) {
      const note = card.querySelector('.conversion-note');
      const status = card.querySelector('.status');
      if (!item.originalFile.type.startsWith('image/')) return;
      if (!isHeicFile(item.originalFile)) {
        item.uploadFile = item.originalFile;
        setPreview(card, item.uploadFile);
        return;
      }

      note.textContent = 'HEIC isn’t supported by most browsers; converting to JPEG for preview + upload.';
      status.textContent = 'Converting HEIC → JPEG...';
      try {
        item.uploadFile = await convertHeicToJpeg(item.originalFile);
        setPreview(card, item.uploadFile);
        status.textContent = `Converted to ${item.uploadFile.name}. Ready.`;
      } catch (err) {
        item.conversionError = `HEIC conversion failed. Please export as JPG and try again. (${err.message})`;
        status.textContent = item.conversionError;
      }
    }

    function updateBatchSummary() {
      const count = filesInput.files.length;
      batchStatus.textContent = count ? `${count} file(s) selected.` : 'No files selected yet.';
      uploadAllBtn.disabled = count === 0;
    }

    filesInput.addEventListener('change', () => {
      clearPreviewUrls();
      queue.innerHTML = '';
      queueItems.length = 0;
      [...filesInput.files].forEach((f) => {
        const item = { originalFile: f, uploadFile: f, conversionError: '' };
        queueItems.push(item);
        const card = fileCard(item);
        queue.appendChild(card);
        prepareFileForUpload(item, card);
      });
      syncMetadataFields();
      updateBatchSummary();
    });

    collectionInput.addEventListener('change', syncMetadataFields);

    uploadAllBtn.addEventListener('click', async () => {
      const cards = [...queue.querySelectorAll('.upload-file')];
      if (!cards.length) return;
      uploadAllBtn.disabled = true;
      batchStatus.textContent = `Uploading ${cards.length} file(s)...`;
      for (const [idx, card] of cards.entries()) {
        const item = queueItems[idx];
        if (!item) continue;
        await uploadFile(item, card);
      }
      batchStatus.textContent = 'Batch upload finished.';
      uploadAllBtn.disabled = false;
    });

    function showResult(card, collection, item, location) {
      const result = card.querySelector('.result');
      const publicLink = PUBLIC_LINKS[collection] || '/';
      const secondaryLine = collection === 'photography'
        ? `Location: ${location || '(none)'}`
        : `Description: ${item.description || '(none)'}`;
      result.innerHTML = `Created item:<br>ID: <code>${item.id}</code><br>Title: ${item.title || '(untitled)'}<br>${secondaryLine}<br>URL: <a href="${item.url}" target="_blank" rel="noreferrer">${item.url}</a><br><a href="${publicLink}" target="_blank" rel="noreferrer">Open public page</a>`;
    }

    function selectedCollection() {
      return collectionInput.value;
    }

    async function uploadFile(item, card) {
      const file = item.uploadFile || item.originalFile;
      const collection = selectedCollection();
      const title = card.querySelector('.title').value;
      const location = card.querySelector('.location')?.value || '';
      const description = collection === 'photography'
        ? location
        : (card.querySelector('.description')?.value || '');
      const progress = card.querySelector('progress');
      const status = card.querySelector('.status');
      const startBtn = card.querySelector('.start');

      if (startBtn.disabled) return;
      startBtn.disabled = true;

      try {
        if (item.conversionError) throw new Error(item.conversionError);
        if (file.type.startsWith('image/')) {
          const dims = await imageDimensions(file);
          status.textContent = 'Initializing image upload...';
          const initRes = await api('/api/admin/image/init', {
            method: 'POST',
            headers: { 'content-type': 'application/json' },
            body: JSON.stringify({ collection, filename: file.name, contentType: file.type })
          });
          if (!initRes.ok) {
            throw Object.assign(new Error(`Image init failed (${initRes.status})`), { step: 'image-init', url: '/api/admin/image/init', status: initRes.status });
          }
          const init = await initRes.json();

          status.textContent = `Uploading image bytes to ${new URL(init.putUrl).host}...`;
          let putRes;
          try {
            putRes = await fetch(init.putUrl, {
              method: 'PUT',
              headers: { 'content-type': init.contentTypeExpected || file.type || 'application/octet-stream' },
              body: file,
            });
          } catch (err) {
            throw Object.assign(err, { step: 'image-put', url: init.putUrl });
          }
          if (!putRes.ok) {
            throw Object.assign(new Error(`Image PUT failed (${putRes.status})`), { step: 'image-put', url: init.putUrl, status: putRes.status });
          }

          status.textContent = 'Finalizing image upload...';
          const completeRes = await api('/api/admin/image/complete', {
            method: 'POST',
            headers: { 'content-type': 'application/json' },
            body: JSON.stringify({ key: init.key, collection, title, description, ...dims })
          });
          if (!completeRes.ok) {
            throw Object.assign(new Error(`Image complete failed (${completeRes.status})`), { step: 'image-complete', url: '/api/admin/image/complete', status: completeRes.status });
          }

          progress.value = 100;
          const created = await completeRes.json();
          status.textContent = 'Image upload complete.';
          showResult(card, collection, created, location);
          return;
        }

        status.textContent = 'Initializing multipart upload...';
        const initRes = await api('/api/admin/multipart/init', {
          method: 'POST',
          headers: { 'content-type': 'application/json' },
          body: JSON.stringify({ collection, filename: file.name, contentType: file.type, title, description })
        });
        if (!initRes.ok) throw Object.assign(new Error(`Failed to initialize upload (${initRes.status})`), { step: 'multipart-init', url: '/api/admin/multipart/init', status: initRes.status });

        const init = await initRes.json();
        const savedKey = `multipart:${init.key}`;
        const chunkSize = init.partSize;
        const totalParts = Math.ceil(file.size / chunkSize);

        let uploaded = {};
        try {
          const st = await api(`/api/admin/multipart/status?key=${encodeURIComponent(init.key)}`);
          if (st.ok) {
            const payload = await st.json();
            (payload.etags || []).forEach((p) => { uploaded[p.partNumber] = p.etag; });
          }
        } catch {}

        const saved = JSON.parse(localStorage.getItem(savedKey) || '{}');
        uploaded = { ...saved, ...uploaded };
        let uploadedBytes = Object.keys(uploaded).length * chunkSize;

        async function uploadPart(partNumber) {
          if (uploaded[partNumber]) return;
          const signRes = await api('/api/admin/multipart/sign-part', {
            method: 'POST',
            headers: { 'content-type': 'application/json' },
            body: JSON.stringify({ key: init.key, uploadId: init.uploadId, partNumber })
          });
          if (!signRes.ok) throw Object.assign(new Error(`Failed to sign part ${partNumber} (${signRes.status})`), { step: `multipart-sign-part-${partNumber}`, url: '/api/admin/multipart/sign-part', status: signRes.status });
          const signed = await signRes.json();

          const start = (partNumber - 1) * chunkSize;
          const end = Math.min(start + chunkSize, file.size);
          const blob = file.slice(start, end);
          let putRes;
          try {
            putRes = await fetch(signed.url, { method: 'PUT', body: blob });
          } catch (err) {
            throw Object.assign(err, { step: `multipart-put-part-${partNumber}`, url: signed.url });
          }
          if (!putRes.ok) throw Object.assign(new Error(`Part ${partNumber} upload failed (${putRes.status})`), { step: `multipart-put-part-${partNumber}`, url: signed.url, status: putRes.status });

          const etag = (putRes.headers.get('etag') || '').replaceAll('"', '');
          if (!etag) throw new Error(`Part ${partNumber} returned empty ETag. Configure R2 CORS ExposeHeaders to include ETag.`);

          uploaded[partNumber] = etag;
          localStorage.setItem(savedKey, JSON.stringify(uploaded));
          uploadedBytes += blob.size;
          progress.value = Math.min(99, Math.round((uploadedBytes / file.size) * 100));
        }

        const concurrency = 3;
        const parts = Array.from({ length: totalParts }, (_, i) => i + 1);
        while (parts.length) {
          const batch = parts.splice(0, concurrency);
          await Promise.all(batch.map(uploadPart));
          status.textContent = `Uploaded ${Object.keys(uploaded).length}/${totalParts} parts...`;
        }

        let posterKey = null;
        const posterFile = card.querySelector('.poster')?.files?.[0];
        if (posterFile) {
          const posterFd = new FormData();
          posterFd.append('file', posterFile);
          posterFd.append('collection', collection);
          const posterResp = await api('/api/admin/upload-poster', { method: 'POST', body: posterFd });
          if (posterResp.ok) posterKey = (await posterResp.json()).key;
        }

        status.textContent = 'Finalizing upload...';
        const completeRes = await api('/api/admin/multipart/complete', {
          method: 'POST',
          headers: { 'content-type': 'application/json' },
          body: JSON.stringify({
            key: init.key,
            uploadId: init.uploadId,
            parts: Object.entries(uploaded).map(([partNumber, etag]) => ({ partNumber: Number(partNumber), etag })),
            title,
            description,
            posterKey,
          })
        });

        if (!completeRes.ok) throw Object.assign(new Error(`Complete call failed (${completeRes.status})`), { step: 'multipart-complete', url: '/api/admin/multipart/complete', status: completeRes.status });

        const item = await completeRes.json();
        localStorage.removeItem(savedKey);
        progress.value = 100;
        status.textContent = 'Video upload complete.';
        showResult(card, collection, item, location);
      } catch (err) {
        const parsed = parseError(err, err);
        status.textContent = errorText(parsed);
        if (parsed.likelyCause.includes('CORS')) {
          card.querySelector('.result').innerHTML = corsHelpPanel();
        }
      } finally {
        startBtn.disabled = false;
      }
    }

    updateBatchSummary();
  </script>
</body>
</html>
