<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Admin Upload ‚Äî Jacob Shields</title>
  <link rel="stylesheet" href="/assets/styles.css" />
</head>
<body>
  <main>
    <p class="nav"><a href="/">‚Üê Back to home</a><span class="dot">‚Ä¢</span><a href="/admin">Admin</a></p>
    <h1>Admin Upload</h1>
    <p class="small-note">This route is protected by Cloudflare Access. Pick a destination, select files, and upload.</p>

    <div class="upload-meta">
      <label>Destination
        <select id="collection">
          <option value="spincline_design_build">Spincline: Design &amp; Build</option>
          <option value="spincline_finished_products">Spincline: Finished Products</option>
          <option value="spincline_in_action">Spincline: In Action (Video)</option>
          <option value="photography">Photography</option>
        </select>
      </label>
      <input id="files" type="file" multiple accept="image/*,video/*" />
      <button id="upload-all" type="button">Upload all files</button>
    </div>
    <div class="small-note" id="env-banner" hidden style="display:block; margin-bottom:10px; color:#ffcc80;"></div>
    <div class="small-note" id="batch-status">No files selected yet.</div>
    <div class="small-note" id="cors-help" hidden>
      <strong>Fix CORS:</strong> If upload PUT requests to R2 fail with ‚ÄúTypeError: Failed to fetch‚Äù, your R2 bucket CORS is likely missing.
      Add this to each bucket for origin <code>https://jacobconlanshields.com</code>:<br>
      <code>[{"AllowedOrigins":["https://jacobconlanshields.com"],"AllowedMethods":["GET","HEAD","PUT","POST","DELETE"],"AllowedHeaders":["*"],"ExposeHeaders":["ETag"],"MaxAgeSeconds":3600}]</code>
    </div>

    <div class="admin-grid" id="queue"></div>
  </main>

  <script type="module">
    const queue = document.getElementById('queue');
    const filesInput = document.getElementById('files');
    const collectionInput = document.getElementById('collection');
    const batchStatus = document.getElementById('batch-status');
    const uploadAllBtn = document.getElementById('upload-all');
    const corsHelp = document.getElementById('cors-help');

    const PUBLIC_LINKS = {
      spincline_design_build: '/spincline#design-build',
      spincline_finished_products: '/spincline#finished-products',
      spincline_in_action: '/spincline#in-action',
      photography: '/photography',
    };

    const selectedItems = [];

    function api(path, opts = {}) {
      return fetch(path, { ...opts, credentials: 'same-origin' });
    }

    function selectedCollection() {
      return collectionInput.value;
    }

    function isPhotographyCollection() {
      return selectedCollection() === 'photography';
    }

    function inferTitle(name = '') {
      return name.replace(/\.[^.]+$/, '').replace(/[_-]+/g, ' ').replace(/\s+/g, ' ').trim();
    }

    function friendlySize(bytes) {
      if (bytes < 1024 * 1024) return `${Math.max(1, Math.round(bytes / 1024))} KB`;
      if (bytes < 1024 * 1024 * 1024) return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
      return `${(bytes / (1024 * 1024 * 1024)).toFixed(2)} GB`;
    }

    function cleanupItem(item) {
      if (item?.previewUrl) {
        URL.revokeObjectURL(item.previewUrl);
        item.previewUrl = null;
      }
    }

    function clearAllItems() {
      selectedItems.forEach(cleanupItem);
      selectedItems.length = 0;
      queue.innerHTML = '';
      corsHelp.hidden = true;
      updateBatchSummary();
    }

    function hostOf(url) {
      try { return new URL(url, location.origin).host; } catch { return 'unknown-host'; }
    }

    async function readErrorBody(resp) {
      const text = await resp.text();
      if (!text) return '';
      try {
        const parsed = JSON.parse(text);
        return JSON.stringify(parsed);
      } catch {
        return text;
      }
    }

    async function checkUploadHealth() {
      const envBanner = document.getElementById('env-banner');
      try {
        const resp = await api('/api/admin/health');
        if (!resp.ok) {
          envBanner.hidden = false;
          envBanner.textContent = `Uploads health check failed (${resp.status}).`;
          return;
        }
        const payload = await resp.json();
        if (!payload.ok) {
          envBanner.hidden = false;
          envBanner.textContent = 'Uploads are not configured in this environment (preview). Use production or add bindings/secrets for preview.';
          uploadAllBtn.disabled = true;
          filesInput.disabled = true;
        }
      } catch (error) {
        envBanner.hidden = false;
        envBanner.textContent = `Could not verify upload configuration: ${error.message || String(error)}`;
      }
    }

    function syncMetadataFields() {
      const photographyMode = isPhotographyCollection();
      for (const item of selectedItems) {
        const card = item.card;
        if (!card) continue;
        const descWrap = card.querySelector('.description-wrap');
        const locationWrap = card.querySelector('.location-wrap');
        if (descWrap) descWrap.hidden = photographyMode;
        if (locationWrap) locationWrap.hidden = !photographyMode;
      }
    }

    function updateBatchSummary() {
      const count = selectedItems.length;
      batchStatus.textContent = count ? `${count} file(s) selected.` : 'No files selected yet.';
      uploadAllBtn.disabled = count === 0;
    }

    function markUploading(item, active) {
      const card = item.card;
      if (!card) return;
      card.classList.toggle('uploading', active);
      card.querySelectorAll('input,textarea,select,button').forEach((el) => {
        if (el.classList.contains('upload-remove')) {
          el.disabled = active || item.uploaded;
          return;
        }
        if (el.classList.contains('start')) {
          el.disabled = active || item.uploaded || !!item.conversionError;
          return;
        }
        el.disabled = active;
      });
    }

    function removeItem(item) {
      const idx = selectedItems.findIndex((entry) => entry.clientId === item.clientId);
      if (idx === -1) return;
      cleanupItem(item);
      const [removed] = selectedItems.splice(idx, 1);
      if (removed?.card) {
        const card = removed.card;
        card.classList.remove('visible');
        window.setTimeout(() => card.remove(), 220);
      }
      updateBatchSummary();
    }

    function isHeic(file) {
      const lower = (file.name || '').toLowerCase();
      return file.type === 'image/heic' || file.type === 'image/heif' || lower.endsWith('.heic') || lower.endsWith('.heif');
    }

    function jpgNameFrom(fileName = 'upload.heic') {
      return fileName.replace(/\.(heic|heif)$/i, '') + '.jpg';
    }

    import heic2any from '/assets/vendor/heic2any.js';

    async function convertHeicToJpeg(file) {
      const converted = await heic2any({ blob: file, toType: 'image/jpeg', quality: 0.9 });
      const blob = Array.isArray(converted) ? converted[0] : converted;
      if (!(blob instanceof Blob)) throw new Error('HEIC conversion did not return a Blob');
      return new File([blob], jpgNameFrom(file.name), { type: 'image/jpeg' });
    }

    function buildCard(item) {
      const file = item.uploadFile;
      const wrap = document.createElement('section');
      wrap.className = 'upload-file upload-fields';
      const thumb = item.previewUrl
        ? `<img class="upload-preview" src="${item.previewUrl}" alt="Preview of ${file.name}" />`
        : `<div class="upload-file-icon" aria-hidden="true">${file.type.startsWith('video/') ? 'üé¨' : 'üìÑ'}</div>`;

      const extraInput = file.type.startsWith('video/')
        ? '<label>Poster image (optional)<input type="file" class="poster" accept="image/*"></label>'
        : '';

      wrap.innerHTML = `
        <div class="upload-file-head">
          <div class="upload-file-main">
            ${thumb}
            <div>
              <h3 class="upload-file-name">${file.name}</h3>
              <div class="small-note">${file.type || 'unknown type'} ¬∑ ${friendlySize(file.size)}</div>
              ${item.heicConverted ? '<div class="small-note">Converted HEIC/HEIF ‚Üí JPEG for upload.</div>' : ''}
              ${item.conversionError ? `<div class="small-note" style="color:#ff9f9f;">HEIC conversion failed: ${item.conversionError}</div>` : ''}
            </div>
          </div>
          <button type="button" class="upload-remove">Remove</button>
        </div>
        <div class="upload-meta">
          <label>Title <input type="text" class="title" value="${item.initialTitle}" placeholder="Title"></label>
          <label class="description-wrap">Description <textarea class="description" rows="3" placeholder="Description"></textarea></label>
          <label class="location-wrap" hidden>Location <input type="text" class="location" placeholder="Location"></label>
          ${extraInput}
          <progress max="100" value="0"></progress>
          <div class="small-note status">${item.conversionError ? 'Blocked: conversion failed.' : 'Ready.'}</div>
          <div class="small-note result"></div>
          <button type="button" class="start" ${item.conversionError ? 'disabled' : ''}>Upload</button>
        </div>`;

      wrap.querySelector('.upload-remove').addEventListener('click', () => removeItem(item));
      wrap.querySelector('.start').addEventListener('click', () => uploadFile(item));
      item.card = wrap;

      requestAnimationFrame(() => wrap.classList.add('visible'));
      return wrap;
    }

    async function imageDimensions(file) {
      if (!file.type.startsWith('image/')) return {};
      try {
        const bmp = await createImageBitmap(file);
        const width = bmp.width;
        const height = bmp.height;
        bmp.close?.();
        return { width, height, aspect_ratio: width / height };
      } catch {
        return {};
      }
    }

    async function makeDisplayVariant(file, maxLongSide = 1600) {
      if (!file.type.startsWith('image/')) return null;
      const bmp = await createImageBitmap(file);
      const scale = Math.min(1, maxLongSide / Math.max(bmp.width, bmp.height));
      const w = Math.max(1, Math.round(bmp.width * scale));
      const h = Math.max(1, Math.round(bmp.height * scale));
      const canvas = document.createElement('canvas');
      canvas.width = w;
      canvas.height = h;
      canvas.getContext('2d').drawImage(bmp, 0, 0, w, h);
      bmp.close?.();
      const blob = await new Promise((resolve) => canvas.toBlob(resolve, 'image/jpeg', 0.88));
      return blob ? new File([blob], file.name.replace(/\.[^.]+$/, '') + '.jpg', { type: 'image/jpeg' }) : null;
    }

    function metadataFor(item) {
      const card = item.card;
      const destination = selectedCollection();
      const title = card.querySelector('.title').value.trim();
      const location = card.querySelector('.location')?.value.trim() || '';
      const description = destination === 'photography'
        ? (location || card.querySelector('.description')?.value.trim() || '')
        : (card.querySelector('.description')?.value.trim() || '');
      return { destination, title, location, description };
    }

    function showResult(card, collection, item) {
      const result = card.querySelector('.result');
      const publicLink = PUBLIC_LINKS[collection] || '/';
      const secondaryLine = collection === 'photography'
        ? `Location: ${item.location || '(none)'}`
        : `Description: ${item.description || '(none)'}`;
      const resolvedUrl = item.url || item.displayUrl || item.originalUrl || '';
      result.innerHTML = `Created item:<br>ID: <code>${item.id}</code><br>Title: ${item.title || '(untitled)'}<br>${secondaryLine}${resolvedUrl ? `<br>URL: <a href=\"${resolvedUrl}\" target=\"_blank\" rel=\"noreferrer\">${resolvedUrl}</a>` : ''}<br><a href=\"${publicLink}\" target=\"_blank\" rel=\"noreferrer\">Open public page</a>`;
    }

    function formatLikelyCause(failure) {
      if (failure.step === 'put' && failure.status == null) return 'Likely R2 CORS misconfiguration or Content-Type/signature mismatch. See CORS snippet above.';
      if (failure.status === 401 || failure.status === 403) return 'Likely auth/signature issue.';
      if (failure.status && failure.status >= 500) return 'Likely server or upstream issue.';
      return 'Likely network request or request-shape issue.';
    }

    function makeUploadError({ step, url, status = null, detail = '' }) {
      const failure = { step, url, host: hostOf(url), status, detail };
      const statusText = status == null ? 'no HTTP response' : `HTTP ${status}`;
      failure.message = `Step ${step} failed (${statusText}) on host ${failure.host}. ${formatLikelyCause(failure)} ${detail}`.trim();
      return failure;
    }

    function showFailure(item, failure) {
      const status = item.card.querySelector('.status');
      status.textContent = `Upload failed: ${failure.message}`;
      if (failure.step === 'put' && failure.status == null) corsHelp.hidden = false;
      console.error('[upload-failure]', failure);
    }

    async function uploadPhotographyBatch(items) {
      const uploading = items.filter((item) => !item.uploaded && !item.conversionError && item.uploadFile.type.startsWith('image/'));
      if (!uploading.length) return;

      for (const item of uploading) {
        markUploading(item, true);
        item.card.querySelector('.status').innerHTML = '<span class="upload-spinner"></span>Preparing batch upload...';
        item.card.querySelector('progress').value = 20;
      }

      try {
        batchStatus.textContent = `Uploading ${uploading.length} photography file(s)...`;
        const fd = new FormData();
        const meta = [];

        for (const item of uploading) {
          const file = item.uploadFile;
          const dims = await imageDimensions(file);
          const display = await makeDisplayVariant(file);
          const info = metadataFor(item);
          meta.push({
            clientId: item.clientId,
            filename: file.name,
            title: info.title,
            location: info.location,
            description: info.description,
            destination: info.destination,
            width: dims.width || null,
            height: dims.height || null,
            originalWidth: dims.width || null,
            originalHeight: dims.height || null,
          });
          fd.append('files[]', file, file.name);
          if (display) fd.append('displayFiles[]', display, display.name);
          else fd.append('displayFiles[]', new File([''], 'empty.jpg', { type: 'application/octet-stream' }));
        }

        fd.append('meta', JSON.stringify(meta));

        const resp = await api('/api/photos/upload', { method: 'POST', body: fd });
        if (!resp.ok) throw new Error(`Batch upload failed (${resp.status}) ${await readErrorBody(resp)}`);
        const payload = await resp.json();
        const byClientId = new Map((payload.items || []).map((entry) => [entry.clientId, entry]));

        for (const item of uploading) {
          const card = item.card;
          const found = byClientId.get(item.clientId);
          if (found) {
            item.uploaded = true;
            card.querySelector('progress').value = 100;
            card.querySelector('.status').textContent = 'Image upload complete.';
            showResult(card, 'photography', found);
          } else {
            card.querySelector('progress').value = 0;
            card.querySelector('.status').textContent = 'Upload did not return an item for this file.';
          }
          markUploading(item, false);
        }
        batchStatus.textContent = `Batch upload finished (${payload.uploaded || 0} photo(s)).`;
      } catch (err) {
        for (const item of uploading) {
          item.card.querySelector('.status').textContent = `Batch upload failed: ${err.message || err}`;
          markUploading(item, false);
        }
        batchStatus.textContent = `Batch upload failed: ${err.message || err}`;
      }
    }

    async function uploadFile(item) {
      const card = item.card;
      const file = item.uploadFile;
      const progress = card.querySelector('progress');
      const status = card.querySelector('.status');
      const info = metadataFor(item);

      if (item.uploaded || item.conversionError) return;

      markUploading(item, true);
      status.innerHTML = '<span class="upload-spinner"></span>Uploading...';

      try {
        if (file.type.startsWith('image/')) {
          if (info.destination === 'photography') {
            await uploadPhotographyBatch([item]);
            return;
          }

          const dims = await imageDimensions(file);
          progress.value = 10;

          let initRes;
          try {
            initRes = await api('/api/admin/image/init', {
              method: 'POST',
              headers: { 'content-type': 'application/json' },
              body: JSON.stringify({ collection: info.destination, filename: file.name, contentType: file.type })
            });
          } catch (err) {
            throw makeUploadError({ step: 'init', url: '/api/admin/image/init', detail: err.message || String(err) });
          }
          if (!initRes.ok) throw makeUploadError({ step: 'init', url: '/api/admin/image/init', status: initRes.status, detail: await readErrorBody(initRes) });

          const init = await initRes.json();
          progress.value = 55;

          let putRes;
          try {
            putRes = await fetch(init.putUrl, {
              method: 'PUT',
              headers: { 'content-type': init.contentTypeExpected || file.type || 'application/octet-stream' },
              body: file,
            });
          } catch (err) {
            throw makeUploadError({ step: 'put', url: init.putUrl, detail: err.message || String(err) });
          }
          if (!putRes.ok) throw makeUploadError({ step: 'put', url: init.putUrl, status: putRes.status, detail: await readErrorBody(putRes) });

          progress.value = 85;
          const completeRes = await api('/api/admin/image/complete', {
            method: 'POST',
            headers: { 'content-type': 'application/json' },
            body: JSON.stringify({
              key: init.key,
              collection: info.destination,
              destination: info.destination,
              title: info.title,
              description: info.description,
              location: info.location,
              ...dims,
              originalWidth: dims.width || null,
              originalHeight: dims.height || null,
            })
          });
          if (!completeRes.ok) throw makeUploadError({ step: 'complete', url: '/api/admin/image/complete', status: completeRes.status, detail: await readErrorBody(completeRes) });
          const complete = await completeRes.json();

          item.uploaded = true;
          progress.value = 100;
          status.textContent = 'Image upload complete.';
          showResult(card, info.destination, { ...complete, location: info.location });
          return;
        }

        const description = info.description;
        const initRes = await api('/api/admin/multipart/init', {
          method: 'POST',
          headers: { 'content-type': 'application/json' },
          body: JSON.stringify({ collection: info.destination, filename: file.name, contentType: file.type, title: info.title, description })
        });
        if (!initRes.ok) throw makeUploadError({ step: 'init', url: '/api/admin/multipart/init', status: initRes.status, detail: await readErrorBody(initRes) });

        const init = await initRes.json();
        const savedKey = `multipart:${init.key}`;
        const chunkSize = init.partSize;
        const totalParts = Math.ceil(file.size / chunkSize);

        let uploaded = {};
        try {
          const st = await api(`/api/admin/multipart/status?key=${encodeURIComponent(init.key)}`);
          if (st.ok) {
            const payload = await st.json();
            (payload.etags || []).forEach((p) => { uploaded[p.partNumber] = p.etag; });
          }
        } catch {}

        const saved = JSON.parse(localStorage.getItem(savedKey) || '{}');
        uploaded = { ...saved, ...uploaded };
        let uploadedBytes = Object.keys(uploaded).length * chunkSize;

        async function uploadPart(partNumber) {
          if (uploaded[partNumber]) return;
          const signRes = await api('/api/admin/multipart/sign-part', {
            method: 'POST',
            headers: { 'content-type': 'application/json' },
            body: JSON.stringify({ key: init.key, uploadId: init.uploadId, partNumber })
          });
          if (!signRes.ok) throw makeUploadError({ step: 'sign-part', url: '/api/admin/multipart/sign-part', status: signRes.status, detail: await readErrorBody(signRes) });
          const signed = await signRes.json();

          const start = (partNumber - 1) * chunkSize;
          const end = Math.min(start + chunkSize, file.size);
          const blob = file.slice(start, end);
          const putRes = await fetch(signed.url, { method: 'PUT', body: blob });
          if (!putRes.ok) throw makeUploadError({ step: `put-part-${partNumber}`, url: signed.url, status: putRes.status, detail: await readErrorBody(putRes) });

          const etag = (putRes.headers.get('etag') || '').replaceAll('"', '');
          if (!etag) throw makeUploadError({ step: `put-part-${partNumber}`, url: signed.url, detail: 'ETag missing. Ensure R2 CORS ExposeHeaders includes ETag.' });

          uploaded[partNumber] = etag;
          localStorage.setItem(savedKey, JSON.stringify(uploaded));
          uploadedBytes += blob.size;
          progress.value = Math.min(99, Math.round((uploadedBytes / file.size) * 100));
          status.innerHTML = `<span class="upload-spinner"></span>Uploaded ${Object.keys(uploaded).length}/${totalParts} parts...`;
        }

        const parts = Array.from({ length: totalParts }, (_, i) => i + 1);
        while (parts.length) {
          const batch = parts.splice(0, 3);
          await Promise.all(batch.map(uploadPart));
        }

        let posterKey = null;
        const posterFile = card.querySelector('.poster')?.files?.[0];
        if (posterFile) {
          const posterFd = new FormData();
          posterFd.append('file', posterFile);
          posterFd.append('collection', info.destination);
          const posterResp = await api('/api/admin/upload-poster', { method: 'POST', body: posterFd });
          if (posterResp.ok) posterKey = (await posterResp.json()).key;
        }

        const completeRes = await api('/api/admin/multipart/complete', {
          method: 'POST',
          headers: { 'content-type': 'application/json' },
          body: JSON.stringify({
            key: init.key,
            uploadId: init.uploadId,
            parts: Object.entries(uploaded).map(([partNumber, etag]) => ({ partNumber: Number(partNumber), etag })),
            title: info.title,
            description,
            destination: info.destination,
            posterKey,
          })
        });
        if (!completeRes.ok) throw makeUploadError({ step: 'complete', url: '/api/admin/multipart/complete', status: completeRes.status, detail: await readErrorBody(completeRes) });

        const result = await completeRes.json();
        localStorage.removeItem(savedKey);
        item.uploaded = true;
        progress.value = 100;
        status.textContent = 'Video upload complete.';
        showResult(card, info.destination, result);
      } catch (failure) {
        showFailure(item, failure?.step ? failure : { message: failure?.message || String(failure), step: 'unknown', status: null, url: 'unknown' });
      } finally {
        markUploading(item, false);
      }
    }

    async function addFiles(rawFiles) {
      batchStatus.textContent = 'Preparing previews...';
      for (const file of rawFiles) {
        const item = {
          clientId: crypto.randomUUID(),
          originalFile: file,
          uploadFile: file,
          previewUrl: null,
          heicConverted: false,
          conversionError: '',
          uploaded: false,
          card: null,
          initialTitle: inferTitle(file.name),
        };

        if (file.type.startsWith('image/') && isHeic(file)) {
          try {
            item.heicConverted = true;
            item.uploadFile = await convertHeicToJpeg(file);
          } catch (err) {
            item.conversionError = err.message || 'Unknown conversion error';
          }
        }

        if (item.uploadFile.type.startsWith('image/') && !item.conversionError) {
          item.previewUrl = URL.createObjectURL(item.uploadFile);
        }

        selectedItems.push(item);
        queue.appendChild(buildCard(item));
      }
      syncMetadataFields();
      updateBatchSummary();
    }

    filesInput.addEventListener('change', async () => {
      clearAllItems();
      const files = [...filesInput.files];
      if (!files.length) return;
      await addFiles(files);
    });

    collectionInput.addEventListener('change', syncMetadataFields);

    uploadAllBtn.addEventListener('click', async () => {
      const pending = selectedItems.filter((item) => !item.uploaded && !item.conversionError);
      if (!pending.length) return;
      uploadAllBtn.disabled = true;

      if (isPhotographyCollection()) {
        await uploadPhotographyBatch(pending);
      } else {
        batchStatus.textContent = `Uploading ${pending.length} file(s)...`;
        for (const item of pending) {
          await uploadFile(item);
        }
        batchStatus.textContent = 'Batch upload finished.';
      }

      uploadAllBtn.disabled = false;
      updateBatchSummary();
    });

    updateBatchSummary();
    checkUploadHealth();
    window.addEventListener('beforeunload', () => selectedItems.forEach(cleanupItem));
  </script>
</body>
</html>
