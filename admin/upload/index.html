<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Admin Upload — Jacob Shields</title>
  <link rel="stylesheet" href="/assets/styles.css" />
</head>
<body>
  <main>
    <p class="nav"><a href="/">← Back to home</a></p>
    <h1>Admin Upload</h1>
    <p class="small-note">This route is protected by Cloudflare Access. Pick a destination, select files, and upload.</p>

    <div class="upload-meta">
      <label>Destination
        <select id="collection">
          <option value="spincline_design_build">Spincline: Design &amp; Build</option>
          <option value="spincline_finished_products">Spincline: Finished Products</option>
          <option value="spincline_in_action">Spincline: In Action (Video)</option>
          <option value="photography">Photography</option>
        </select>
      </label>
      <input id="files" type="file" multiple accept="image/*,video/*" />
      <button id="upload-all" type="button">Upload all files</button>
    </div>
    <div class="small-note" id="batch-status">No files selected yet.</div>

    <div class="admin-grid" id="queue"></div>
  </main>

  <script>
    const queue = document.getElementById('queue');
    const filesInput = document.getElementById('files');
    const collectionInput = document.getElementById('collection');
    const batchStatus = document.getElementById('batch-status');
    const uploadAllBtn = document.getElementById('upload-all');

    const PUBLIC_LINKS = {
      spincline_design_build: '/spincline#design-build',
      spincline_finished_products: '/spincline#finished-products',
      spincline_in_action: '/spincline#in-action',
      photography: '/photography',
    };

    function api(path, opts = {}) {
      return fetch(path, { ...opts, credentials: 'same-origin' });
    }

    function isPhotographyCollection() {
      return collectionInput.value === 'photography';
    }

    function syncMetadataFields() {
      const photographyMode = isPhotographyCollection();
      queue.querySelectorAll('.upload-file').forEach((card) => {
        const descWrap = card.querySelector('.description-wrap');
        const locationWrap = card.querySelector('.location-wrap');
        if (descWrap) descWrap.hidden = photographyMode;
        if (locationWrap) locationWrap.hidden = !photographyMode;
      });
    }

    function friendlySize(bytes) {
      if (bytes < 1024 * 1024) return `${Math.max(1, Math.round(bytes / 1024))} KB`;
      if (bytes < 1024 * 1024 * 1024) return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
      return `${(bytes / (1024 * 1024 * 1024)).toFixed(2)} GB`;
    }

    function clearPreviewUrls() {
      queue.querySelectorAll('.upload-preview').forEach((img) => {
        if (img.dataset.objectUrl) URL.revokeObjectURL(img.dataset.objectUrl);
      });
    }

    function fileCard(file) {
      const wrap = document.createElement('section');
      wrap.className = 'upload-file';
      const previewUrl = file.type.startsWith('image/') ? URL.createObjectURL(file) : null;
      const imagePreview = file.type.startsWith('image/')
        ? `<img class="upload-preview" data-object-url="${previewUrl}" src="${previewUrl}" alt="Preview of ${file.name}" style="max-width:220px; max-height:220px; object-fit:cover; border-radius:8px; margin-top:8px;" />`
        : '';
      wrap.innerHTML = `
        <h3>${file.name}</h3>
        <div class="small-note">${file.type || 'unknown type'} · ${friendlySize(file.size)}</div>
        ${imagePreview}
        <div class="upload-meta">
          <label>Title <input type="text" class="title" placeholder="Optional"></label>
          <label class="description-wrap">Description <textarea class="description" rows="3" placeholder="Optional"></textarea></label>
          <label class="location-wrap" hidden>Location <input type="text" class="location" placeholder="Optional"></label>
          ${file.type.startsWith('video/') ? '<label>Poster image (optional)<input type="file" class="poster" accept="image/*"></label>' : ''}
          <progress max="100" value="0"></progress>
          <div class="small-note status">Ready.</div>
          <div class="small-note result"></div>
          <button type="button" class="start">Upload</button>
        </div>`;
      wrap.querySelector('.start').addEventListener('click', () => uploadFile(file, wrap));
      return wrap;
    }

    function updateBatchSummary() {
      const count = filesInput.files.length;
      batchStatus.textContent = count ? `${count} file(s) selected.` : 'No files selected yet.';
      uploadAllBtn.disabled = count === 0;
    }

    filesInput.addEventListener('change', () => {
      clearPreviewUrls();
      queue.innerHTML = '';
      [...filesInput.files].forEach((f) => queue.appendChild(fileCard(f)));
      syncMetadataFields();
      updateBatchSummary();
    });

    collectionInput.addEventListener('change', syncMetadataFields);

    uploadAllBtn.addEventListener('click', async () => {
      const cards = [...queue.querySelectorAll('.upload-file')];
      if (!cards.length) return;
      uploadAllBtn.disabled = true;
      batchStatus.textContent = `Uploading ${cards.length} file(s)...`;
      for (const [idx, card] of cards.entries()) {
        const file = filesInput.files[idx];
        if (!file) continue;
        await uploadFile(file, card);
      }
      batchStatus.textContent = 'Batch upload finished.';
      uploadAllBtn.disabled = false;
    });

    async function imageDimensions(file) {
      return new Promise((resolve) => {
        if (!file.type.startsWith('image/')) return resolve({});
        const img = new Image();
        img.onload = () => resolve({ width: img.naturalWidth, height: img.naturalHeight, aspect_ratio: img.naturalWidth / img.naturalHeight });
        img.onerror = () => resolve({});
        img.src = URL.createObjectURL(file);
      });
    }

    function showResult(card, collection, item, location) {
      const result = card.querySelector('.result');
      const publicLink = PUBLIC_LINKS[collection] || '/';
      const secondaryLine = collection === 'photography'
        ? `Location: ${location || '(none)'}`
        : `Description: ${item.description || '(none)'}`;
      result.innerHTML = `Created item:<br>ID: <code>${item.id}</code><br>Title: ${item.title || '(untitled)'}<br>${secondaryLine}<br>URL: <a href="${item.url}" target="_blank" rel="noreferrer">${item.url}</a><br><a href="${publicLink}" target="_blank" rel="noreferrer">Open public page</a>`;
    }

    function selectedCollection() {
      return collectionInput.value;
    }

    async function uploadFile(file, card) {
      const collection = selectedCollection();
      const title = card.querySelector('.title').value;
      const location = card.querySelector('.location')?.value || '';
      const description = collection === 'photography'
        ? location
        : (card.querySelector('.description')?.value || '');
      const progress = card.querySelector('progress');
      const status = card.querySelector('.status');
      const startBtn = card.querySelector('.start');

      if (startBtn.disabled) return;
      startBtn.disabled = true;

      try {
        if (file.type.startsWith('image/')) {
          const dims = await imageDimensions(file);
          const fd = new FormData();
          fd.append('file', file);
          fd.append('collection', collection);
          fd.append('title', title);
          fd.append('description', description);
          if (dims.width) {
            fd.append('width', dims.width);
            fd.append('height', dims.height);
            fd.append('aspect_ratio', dims.aspect_ratio);
          }

          status.textContent = 'Uploading image...';
          const res = await api('/api/admin/upload-image', { method: 'POST', body: fd });
          progress.value = 100;
          if (!res.ok) throw new Error(`Image upload failed (${res.status})`);
          const item = await res.json();
          status.textContent = 'Image upload complete.';
          showResult(card, collection, item, location);
          return;
        }

        status.textContent = 'Initializing multipart upload...';
        const initRes = await api('/api/admin/multipart/init', {
          method: 'POST',
          headers: { 'content-type': 'application/json' },
          body: JSON.stringify({ collection, filename: file.name, contentType: file.type, title, description })
        });
        if (!initRes.ok) throw new Error(`Failed to initialize upload (${initRes.status})`);

        const init = await initRes.json();
        const savedKey = `multipart:${init.key}`;
        const chunkSize = init.partSize;
        const totalParts = Math.ceil(file.size / chunkSize);

        let uploaded = {};
        try {
          const st = await api(`/api/admin/multipart/status?key=${encodeURIComponent(init.key)}`);
          if (st.ok) {
            const payload = await st.json();
            (payload.etags || []).forEach((p) => { uploaded[p.partNumber] = p.etag; });
          }
        } catch {}

        const saved = JSON.parse(localStorage.getItem(savedKey) || '{}');
        uploaded = { ...saved, ...uploaded };
        let uploadedBytes = Object.keys(uploaded).length * chunkSize;

        async function uploadPart(partNumber) {
          if (uploaded[partNumber]) return;
          const signRes = await api('/api/admin/multipart/sign-part', {
            method: 'POST',
            headers: { 'content-type': 'application/json' },
            body: JSON.stringify({ key: init.key, uploadId: init.uploadId, partNumber })
          });
          if (!signRes.ok) throw new Error(`Failed to sign part ${partNumber} (${signRes.status})`);
          const signed = await signRes.json();

          const start = (partNumber - 1) * chunkSize;
          const end = Math.min(start + chunkSize, file.size);
          const blob = file.slice(start, end);
          const putRes = await fetch(signed.url, { method: 'PUT', body: blob });
          if (!putRes.ok) throw new Error(`Part ${partNumber} upload failed (${putRes.status})`);

          const etag = (putRes.headers.get('etag') || '').replaceAll('"', '');
          if (!etag) throw new Error(`Part ${partNumber} returned empty ETag`);

          uploaded[partNumber] = etag;
          localStorage.setItem(savedKey, JSON.stringify(uploaded));
          uploadedBytes += blob.size;
          progress.value = Math.min(99, Math.round((uploadedBytes / file.size) * 100));
        }

        const concurrency = 3;
        const parts = Array.from({ length: totalParts }, (_, i) => i + 1);
        while (parts.length) {
          const batch = parts.splice(0, concurrency);
          await Promise.all(batch.map(uploadPart));
          status.textContent = `Uploaded ${Object.keys(uploaded).length}/${totalParts} parts...`;
        }

        let posterKey = null;
        const posterFile = card.querySelector('.poster')?.files?.[0];
        if (posterFile) {
          const posterFd = new FormData();
          posterFd.append('file', posterFile);
          posterFd.append('collection', collection);
          const posterResp = await api('/api/admin/upload-poster', { method: 'POST', body: posterFd });
          if (posterResp.ok) posterKey = (await posterResp.json()).key;
        }

        status.textContent = 'Finalizing upload...';
        const completeRes = await api('/api/admin/multipart/complete', {
          method: 'POST',
          headers: { 'content-type': 'application/json' },
          body: JSON.stringify({
            key: init.key,
            uploadId: init.uploadId,
            parts: Object.entries(uploaded).map(([partNumber, etag]) => ({ partNumber: Number(partNumber), etag })),
            title,
            description,
            posterKey,
          })
        });

        if (!completeRes.ok) throw new Error(`Complete call failed (${completeRes.status})`);

        const item = await completeRes.json();
        localStorage.removeItem(savedKey);
        progress.value = 100;
        status.textContent = 'Video upload complete.';
        showResult(card, collection, item, location);
      } catch (err) {
        status.textContent = `Upload failed: ${err.message}`;
      } finally {
        startBtn.disabled = false;
      }
    }

    updateBatchSummary();
  </script>
</body>
</html>
