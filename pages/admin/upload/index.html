<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Admin Upload ‚Äî Jacob Shields</title>
  <link rel="stylesheet" href="/assets/styles.css" />
</head>
<body>
  <main>
    <p class="nav"><a href="/">‚Üê Back to home</a><span class="dot">‚Ä¢</span><a href="/admin">Admin</a></p>
    <h1>Admin Upload</h1>
    <p class="small-note">This route is protected by Cloudflare Access. Pick a destination, select files, and upload.</p>

    <div class="upload-meta upload-controls">
      <label>Destination
        <select id="collection">
          <option value="spincline_design_build">Spincline: Design &amp; Build</option>
          <option value="spincline_finished_products">Spincline: Finished Products</option>
          <option value="spincline_in_action">Spincline: In Action (Video)</option>
          <option value="photography">Photography</option>
        </select>
      </label>
      <input id="files" type="file" multiple accept="image/*,video/*" />
      <button id="upload-all" type="button">Upload all files</button>
    </div>
    <div class="small-note" id="env-banner" hidden style="display:block; margin-bottom:10px; color:#ffcc80;"></div>
    <div class="small-note" id="batch-status">No files selected yet.</div>
    <div class="small-note" id="cors-help" hidden>
      <strong>Fix CORS:</strong> If upload PUT requests to R2 fail with ‚ÄúTypeError: Failed to fetch‚Äù, your R2 bucket CORS is likely missing.
      Add this to each bucket for origin <code>https://jacobconlanshields.com</code>:<br>
      <code>[{"AllowedOrigins":["https://jacobconlanshields.com"],"AllowedMethods":["GET","HEAD","PUT","POST","DELETE"],"AllowedHeaders":["*"],"ExposeHeaders":["ETag"],"MaxAgeSeconds":3600}]</code>
    </div>

    <div class="admin-grid" id="queue"></div>
    <div class="upload-actions-bottom"><button id="upload-all-bottom" type="button">Upload all files</button></div>
  </main>

  <script type="module">
    import heic2any from '/assets/vendor/heic2any.js';

    const queue = document.getElementById('queue');
    const filesInput = document.getElementById('files');
    const collectionInput = document.getElementById('collection');
    const batchStatus = document.getElementById('batch-status');
    const uploadAllBtns = [document.getElementById('upload-all'), document.getElementById('upload-all-bottom')];
    const corsHelp = document.getElementById('cors-help');

    const PUBLIC_LINKS = {
      spincline_design_build: '/spincline#design-build',
      spincline_finished_products: '/spincline#finished-products',
      spincline_in_action: '/spincline#in-action',
      photography: '/photography',
    };

    const selectedItems = [];
    let uploadsInProgress = false;

    function api(path, opts = {}) {
      return fetch(path, { ...opts, credentials: 'same-origin' });
    }

    function destinationConfig(value = collectionInput.value) {
      return value === 'photography'
        ? { secondaryLabel: 'Location', secondaryKind: 'location', isPhoto: true }
        : { secondaryLabel: 'Description', secondaryKind: 'description', isPhoto: false };
    }

    function titleFromFilename(name = '') {
      return name.replace(/\.[^.]+$/, '').replace(/[_-]+/g, ' ').replace(/\s+/g, ' ').trim();
    }

    function friendlySize(bytes) {
      if (bytes < 1024 * 1024) return `${Math.max(1, Math.round(bytes / 1024))} KB`;
      if (bytes < 1024 * 1024 * 1024) return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
      return `${(bytes / (1024 * 1024 * 1024)).toFixed(2)} GB`;
    }

    function isHeic(file) {
      const lower = (file.name || '').toLowerCase();
      return file.type === 'image/heic' || file.type === 'image/heif' || lower.endsWith('.heic') || lower.endsWith('.heif');
    }

    function jpgNameFrom(fileName = 'upload.heic') {
      return fileName.replace(/\.(heic|heif)$/i, '') + '.jpg';
    }

    async function convertHeicToJpeg(file) {
      const converted = await heic2any({ blob: file, toType: 'image/jpeg', quality: 0.9 });
      const blob = Array.isArray(converted) ? converted[0] : converted;
      if (!(blob instanceof Blob)) throw new Error('HEIC conversion did not return a Blob');
      return new File([blob], jpgNameFrom(file.name), { type: 'image/jpeg' });
    }

    function cleanupItem(item) {
      if (item?.previewUrl) URL.revokeObjectURL(item.previewUrl);
    }

    function setControlsDisabled(disabled) {
      uploadsInProgress = disabled;
      collectionInput.disabled = disabled;
      filesInput.disabled = disabled;
      uploadAllBtns.forEach((btn) => { btn.disabled = disabled || selectedItems.length === 0; });
      queue.querySelectorAll('input, textarea, button.start, button.remove').forEach((el) => {
        if (el.classList.contains('remove') && el.closest('.upload-file')?.dataset.status === 'uploading') {
          el.disabled = true;
          return;
        }
        el.disabled = disabled;
      });
    }

    function updateBatchSummary() {
      batchStatus.textContent = selectedItems.length ? `${selectedItems.length} file(s) selected.` : 'No files selected yet.';
      uploadAllBtns.forEach((btn) => { btn.disabled = uploadsInProgress || selectedItems.length === 0; });
    }

    function syncMetadataFields() {
      const config = destinationConfig();
      queue.querySelectorAll('.upload-file').forEach((card) => {
        const label = card.querySelector('.secondary-label');
        const input = card.querySelector('.secondary-input');
        if (!label || !input) return;
        label.textContent = config.secondaryLabel;
        if (config.secondaryKind === 'description' && input.tagName === 'INPUT') {
          const next = document.createElement('textarea');
          next.className = 'secondary-input';
          next.rows = 3;
          next.placeholder = 'Optional';
          next.value = input.value;
          input.replaceWith(next);
        }
        if (config.secondaryKind === 'location' && input.tagName === 'TEXTAREA') {
          const next = document.createElement('input');
          next.className = 'secondary-input';
          next.type = 'text';
          next.placeholder = 'Optional';
          next.value = input.value;
          input.replaceWith(next);
        }
      });
    }

    function removeItem(clientId) {
      const idx = selectedItems.findIndex((item) => item.clientId === clientId);
      if (idx < 0) return;
      cleanupItem(selectedItems[idx]);
      selectedItems.splice(idx, 1);
      queue.querySelector(`[data-client-id="${clientId}"]`)?.remove();
      updateBatchSummary();
    }

    function animateIn(card) {
      requestAnimationFrame(() => card.classList.add('visible'));
    }

    function makePreview(item) {
      if (item.uploadFile.type.startsWith('image/') && item.previewUrl) {
        return `<img class="upload-thumb" src="${item.previewUrl}" alt="Preview for ${item.uploadFile.name}" />`;
      }
      return '<div class="upload-thumb upload-thumb--generic" aria-hidden="true">üìÑ</div>';
    }

    function fileCard(item) {
      const config = destinationConfig();
      const card = document.createElement('section');
      card.className = 'upload-file';
      card.dataset.clientId = item.clientId;
      card.dataset.status = 'ready';

      card.innerHTML = `
        <div class="upload-row">
          ${makePreview(item)}
          <div class="upload-file-meta">
            <h3>${item.uploadFile.name}</h3>
            <div class="small-note">${item.uploadFile.type || 'unknown type'} ¬∑ ${friendlySize(item.uploadFile.size)}</div>
          </div>
          <button type="button" class="remove">Remove</button>
        </div>
        <div class="small-note" style="color:#ff9f9f;" ${item.conversionError ? '' : 'hidden'}>${item.conversionError || ''}</div>
        <div class="upload-meta upload-fields">
          <label>Title <input type="text" class="title" value="${titleFromFilename(item.uploadFile.name)}" placeholder="Optional"></label>
          <label><span class="secondary-label">${config.secondaryLabel}</span> ${config.secondaryKind === 'location' ? '<input type="text" class="secondary-input" placeholder="Optional">' : '<textarea class="secondary-input" rows="3" placeholder="Optional"></textarea>'}</label>
          ${item.uploadFile.type.startsWith('video/') ? '<label>Poster image (optional)<input type="file" class="poster" accept="image/*"></label>' : ''}
          <progress max="100" value="0"></progress>
          <div class="small-note status">${item.conversionError ? 'Blocked: conversion failed.' : 'Ready.'}</div>
          <div class="small-note result"></div>
          <button type="button" class="start" ${item.conversionError ? 'disabled' : ''}>Upload</button>
        </div>`;

      card.querySelector('.remove').addEventListener('click', () => removeItem(item.clientId));
      card.querySelector('.start').addEventListener('click', () => uploadSingle(item.clientId));
      return card;
    }

    async function readErrorBody(resp) {
      const text = await resp.text();
      if (!text) return '';
      try { return JSON.stringify(JSON.parse(text)); } catch { return text; }
    }

    function hostOf(url) {
      try { return new URL(url, location.origin).host; } catch { return 'unknown-host'; }
    }

    function makeUploadError({ step, url, status = null, detail = '' }) {
      const statusText = status == null ? 'no HTTP response' : `HTTP ${status}`;
      return { step, status, url, message: `Step ${step} failed (${statusText}) on host ${hostOf(url)}. ${detail}`.trim() };
    }

    function showFailure(card, failure) {
      card.dataset.status = 'failed';
      card.querySelector('.status').textContent = `Upload failed: ${failure.message || failure}`;
      if (failure.step === 'put' && failure.status == null) corsHelp.hidden = false;
    }

    function showResult(card, collection, item, secondaryValue) {
      const result = card.querySelector('.result');
      const publicLink = PUBLIC_LINKS[collection] || '/';
      const secondaryLine = collection === 'photography'
        ? `Location: ${secondaryValue || '(none)'}`
        : `Description: ${item.description || '(none)'}`;
      result.innerHTML = `Created item:<br>ID: <code>${item.id}</code><br>Title: ${item.title || '(untitled)'}<br>${secondaryLine}<br>URL: <a href="${item.url}" target="_blank" rel="noreferrer">${item.url}</a><br><a href="${publicLink}" target="_blank" rel="noreferrer">Open public page</a>`;
    }

    async function imageDimensions(file) {
      if (!file.type.startsWith('image/')) return {};
      try {
        const bmp = await createImageBitmap(file);
        const width = bmp.width;
        const height = bmp.height;
        bmp.close?.();
        return { width, height, aspect_ratio: width / height };
      } catch { return {}; }
    }

    async function makeDisplayVariant(file, maxLongSide = 1600) {
      if (!file.type.startsWith('image/')) return null;
      const bmp = await createImageBitmap(file);
      const scale = Math.min(1, maxLongSide / Math.max(bmp.width, bmp.height));
      const w = Math.max(1, Math.round(bmp.width * scale));
      const h = Math.max(1, Math.round(bmp.height * scale));
      const canvas = document.createElement('canvas');
      canvas.width = w;
      canvas.height = h;
      canvas.getContext('2d').drawImage(bmp, 0, 0, w, h);
      bmp.close?.();
      const blob = await new Promise((resolve) => canvas.toBlob(resolve, 'image/jpeg', 0.88));
      return blob ? new File([blob], file.name.replace(/\.[^.]+$/, '') + '.jpg', { type: 'image/jpeg' }) : null;
    }

    async function uploadPhotographyBatch(ids) {
      const cards = ids.map((id) => queue.querySelector(`[data-client-id="${id}"]`)).filter(Boolean);
      const fd = new FormData();
      const meta = [];

      for (const clientId of ids) {
        const item = selectedItems.find((entry) => entry.clientId === clientId);
        const card = queue.querySelector(`[data-client-id="${clientId}"]`);
        if (!item || !card || item.conversionError || !item.uploadFile.type.startsWith('image/')) continue;

        const title = card.querySelector('.title').value.trim();
        const location = card.querySelector('.secondary-input').value.trim();
        const dims = await imageDimensions(item.uploadFile);
        const display = await makeDisplayVariant(item.uploadFile);

        fd.append('files', item.uploadFile, item.uploadFile.name);
        fd.append('displayFiles', display || new File([''], 'empty.jpg', { type: 'application/octet-stream' }), display?.name || 'empty.jpg');
        meta.push({
          clientId,
          filename: item.uploadFile.name,
          title,
          location,
          description: location,
          destination: 'photography',
          width: dims.width || null,
          height: dims.height || null,
        });

        card.dataset.status = 'uploading';
        card.querySelector('.status').textContent = 'Queued in batch upload...';
        card.querySelector('progress').value = 40;
      }

      fd.append('meta', JSON.stringify(meta));

      const resp = await api('/api/photos/upload', { method: 'POST', body: fd });
      if (!resp.ok) throw new Error(`Batch upload failed (${resp.status}) ${await readErrorBody(resp)}`);
      const payload = await resp.json();
      const byClientId = new Map((payload.items || []).map((entry) => [entry.clientId, entry]));

      for (const card of cards) {
        const clientId = card.dataset.clientId;
        const uploaded = byClientId.get(clientId);
        if (!uploaded) continue;
        card.dataset.status = 'success';
        card.querySelector('progress').value = 100;
        card.querySelector('.status').textContent = 'Image upload complete.';
        showResult(card, 'photography', { ...uploaded, url: `/photos/${uploaded.displayKey || uploaded.originalKey}` }, uploaded.location || '');
      }

      return payload.uploaded || 0;
    }

    async function uploadSingle(clientId) {
      const item = selectedItems.find((entry) => entry.clientId === clientId);
      const card = queue.querySelector(`[data-client-id="${clientId}"]`);
      if (!item || !card || item.conversionError) return;

      const file = item.uploadFile;
      const collection = collectionInput.value;
      const title = card.querySelector('.title').value.trim();
      const secondary = card.querySelector('.secondary-input').value.trim();
      const description = collection === 'photography' ? secondary : secondary;
      const progress = card.querySelector('progress');
      const status = card.querySelector('.status');

      card.dataset.status = 'uploading';
      card.querySelectorAll('input, textarea, button').forEach((el) => { el.disabled = true; });

      try {
        if (file.type.startsWith('image/')) {
          if (collection === 'photography') {
            const uploadedCount = await uploadPhotographyBatch([clientId]);
            batchStatus.textContent = uploadedCount ? '1 file uploaded.' : 'No files uploaded.';
            return;
          }

          const dims = await imageDimensions(file);
          status.textContent = 'Initializing image upload...';
          progress.value = 10;

          const initRes = await api('/api/admin/image/init', {
            method: 'POST',
            headers: { 'content-type': 'application/json' },
            body: JSON.stringify({ collection, filename: file.name, contentType: file.type })
          });
          if (!initRes.ok) throw makeUploadError({ step: 'init', url: '/api/admin/image/init', status: initRes.status, detail: await readErrorBody(initRes) });

          const init = await initRes.json();
          status.textContent = `Uploading image bytes to ${hostOf(init.putUrl)}...`;
          progress.value = 60;

          const putRes = await fetch(init.putUrl, {
            method: 'PUT',
            headers: { 'content-type': init.contentTypeExpected || file.type || 'application/octet-stream' },
            body: file,
          });
          if (!putRes.ok) throw makeUploadError({ step: 'put', url: init.putUrl, status: putRes.status, detail: await readErrorBody(putRes) });

          const completeRes = await api('/api/admin/image/complete', {
            method: 'POST',
            headers: { 'content-type': 'application/json' },
            body: JSON.stringify({ key: init.key, collection, title, description, destination: collection, ...dims })
          });
          if (!completeRes.ok) throw makeUploadError({ step: 'complete', url: '/api/admin/image/complete', status: completeRes.status, detail: await readErrorBody(completeRes) });

          const complete = await completeRes.json();
          progress.value = 100;
          status.textContent = 'Image upload complete.';
          card.dataset.status = 'success';
          showResult(card, collection, complete, secondary);
          return;
        }

        status.textContent = 'Initializing multipart upload...';
        const initRes = await api('/api/admin/multipart/init', {
          method: 'POST',
          headers: { 'content-type': 'application/json' },
          body: JSON.stringify({ collection, filename: file.name, contentType: file.type, title, description, destination: collection })
        });
        if (!initRes.ok) throw makeUploadError({ step: 'init', url: '/api/admin/multipart/init', status: initRes.status, detail: await readErrorBody(initRes) });

        const init = await initRes.json();
        const chunkSize = init.partSize;
        const totalParts = Math.ceil(file.size / chunkSize);
        const uploaded = {};

        for (let partNumber = 1; partNumber <= totalParts; partNumber += 1) {
          const signRes = await api('/api/admin/multipart/sign-part', {
            method: 'POST', headers: { 'content-type': 'application/json' },
            body: JSON.stringify({ key: init.key, uploadId: init.uploadId, partNumber })
          });
          if (!signRes.ok) throw makeUploadError({ step: `sign-part-${partNumber}`, url: '/api/admin/multipart/sign-part', status: signRes.status, detail: await readErrorBody(signRes) });

          const signed = await signRes.json();
          const start = (partNumber - 1) * chunkSize;
          const end = Math.min(start + chunkSize, file.size);
          const putRes = await fetch(signed.url, { method: 'PUT', body: file.slice(start, end) });
          if (!putRes.ok) throw makeUploadError({ step: `put-part-${partNumber}`, url: signed.url, status: putRes.status, detail: await readErrorBody(putRes) });

          uploaded[partNumber] = (putRes.headers.get('etag') || '').replaceAll('"', '');
          progress.value = Math.min(99, Math.round((partNumber / totalParts) * 100));
          status.textContent = `Uploaded ${partNumber}/${totalParts} parts...`;
        }

        let posterKey = null;
        const posterFile = card.querySelector('.poster')?.files?.[0];
        if (posterFile) {
          const posterFd = new FormData();
          posterFd.append('file', posterFile);
          posterFd.append('collection', collection);
          const posterResp = await api('/api/admin/upload-poster', { method: 'POST', body: posterFd });
          if (posterResp.ok) posterKey = (await posterResp.json()).key;
        }

        const completeRes = await api('/api/admin/multipart/complete', {
          method: 'POST',
          headers: { 'content-type': 'application/json' },
          body: JSON.stringify({
            key: init.key,
            uploadId: init.uploadId,
            parts: Object.entries(uploaded).map(([partNumber, etag]) => ({ partNumber: Number(partNumber), etag })),
            title,
            description,
            destination: collection,
            posterKey,
          })
        });
        if (!completeRes.ok) throw makeUploadError({ step: 'complete', url: '/api/admin/multipart/complete', status: completeRes.status, detail: await readErrorBody(completeRes) });

        const result = await completeRes.json();
        progress.value = 100;
        status.textContent = 'Video upload complete.';
        card.dataset.status = 'success';
        showResult(card, collection, result, secondary);
      } catch (failure) {
        showFailure(card, failure);
      } finally {
        if (!uploadsInProgress) {
          const keepDisabled = card.dataset.status === 'success';
          card.querySelectorAll('input, textarea').forEach((el) => { el.disabled = keepDisabled; });
          card.querySelectorAll('button.start').forEach((el) => { el.disabled = keepDisabled; });
          card.querySelectorAll('button.remove').forEach((el) => { el.disabled = false; });
        }
      }
    }

    async function uploadAll() {
      if (!selectedItems.length || uploadsInProgress) return;
      setControlsDisabled(true);
      try {
        const ids = selectedItems.map((item) => item.clientId);
        if (destinationConfig().isPhoto) {
          const uploaded = await uploadPhotographyBatch(ids);
          batchStatus.textContent = `Batch upload finished (${uploaded} photo(s)).`;
        } else {
          batchStatus.textContent = `Uploading ${ids.length} file(s)...`;
          for (const clientId of ids) {
            await uploadSingle(clientId);
          }
          batchStatus.textContent = 'Batch upload finished.';
        }
      } catch (err) {
        batchStatus.textContent = `Batch upload failed: ${err.message || err}`;
      } finally {
        setControlsDisabled(false);
      }
    }

    filesInput.addEventListener('change', async () => {
      selectedItems.splice(0, selectedItems.length).forEach(cleanupItem);
      queue.innerHTML = '';
      corsHelp.hidden = true;
      batchStatus.textContent = 'Preparing previews...';

      for (const originalFile of [...filesInput.files]) {
        const item = { clientId: crypto.randomUUID(), originalFile, uploadFile: originalFile, previewUrl: null, conversionError: '' };
        if (originalFile.type.startsWith('image/') && isHeic(originalFile)) {
          try {
            item.uploadFile = await convertHeicToJpeg(originalFile);
          } catch (err) {
            item.conversionError = err.message || 'HEIC conversion failed';
          }
        }

        if (item.uploadFile.type.startsWith('image/') && !item.conversionError) {
          item.previewUrl = URL.createObjectURL(item.uploadFile);
        }

        selectedItems.push(item);
        const card = fileCard(item);
        queue.appendChild(card);
        animateIn(card);
      }

      syncMetadataFields();
      updateBatchSummary();
    });

    collectionInput.addEventListener('change', syncMetadataFields);
    uploadAllBtns.forEach((btn) => btn.addEventListener('click', uploadAll));

    async function checkUploadHealth() {
      const envBanner = document.getElementById('env-banner');
      try {
        const resp = await api('/api/admin/health');
        if (!resp.ok) {
          envBanner.hidden = false;
          envBanner.textContent = `Uploads health check failed (${resp.status}).`;
          return;
        }
        const payload = await resp.json();
        if (!payload.ok) {
          envBanner.hidden = false;
          envBanner.textContent = 'Uploads are not configured in this environment (preview). Use production or add bindings/secrets for preview.';
          setControlsDisabled(true);
        }
      } catch (error) {
        envBanner.hidden = false;
        envBanner.textContent = `Could not verify upload configuration: ${error.message || String(error)}`;
      }
    }

    updateBatchSummary();
    checkUploadHealth();
    window.addEventListener('beforeunload', () => selectedItems.forEach(cleanupItem));
  </script>
</body>
</html>
